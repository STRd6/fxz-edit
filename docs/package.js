(function(pkg) {
  (function() {
  var annotateSourceURL, cacheFor, circularGuard, defaultEntryPoint, fileSeparator, generateRequireFn, global, isPackage, loadModule, loadPackage, loadPath, normalizePath, publicAPI, rootModule, startsWith,
    __slice = [].slice;

  fileSeparator = '/';

  global = self;

  defaultEntryPoint = "main";

  circularGuard = {};

  rootModule = {
    path: ""
  };

  loadPath = function(parentModule, pkg, path) {
    var cache, localPath, module, normalizedPath;
    if (startsWith(path, '/')) {
      localPath = [];
    } else {
      localPath = parentModule.path.split(fileSeparator);
    }
    normalizedPath = normalizePath(path, localPath);
    cache = cacheFor(pkg);
    if (module = cache[normalizedPath]) {
      if (module === circularGuard) {
        throw "Circular dependency detected when requiring " + normalizedPath;
      }
    } else {
      cache[normalizedPath] = circularGuard;
      try {
        cache[normalizedPath] = module = loadModule(pkg, normalizedPath);
      } finally {
        if (cache[normalizedPath] === circularGuard) {
          delete cache[normalizedPath];
        }
      }
    }
    return module.exports;
  };

  normalizePath = function(path, base) {
    var piece, result;
    if (base == null) {
      base = [];
    }
    base = base.concat(path.split(fileSeparator));
    result = [];
    while (base.length) {
      switch (piece = base.shift()) {
        case "..":
          result.pop();
          break;
        case "":
        case ".":
          break;
        default:
          result.push(piece);
      }
    }
    return result.join(fileSeparator);
  };

  loadPackage = function(pkg) {
    var path;
    path = pkg.entryPoint || defaultEntryPoint;
    return loadPath(rootModule, pkg, path);
  };

  loadModule = function(pkg, path) {
    var args, content, context, dirname, file, module, program, values;
    if (!(file = pkg.distribution[path])) {
      throw "Could not find file at " + path + " in " + pkg.name;
    }
    if ((content = file.content) == null) {
      throw "Malformed package. No content for file at " + path + " in " + pkg.name;
    }
    program = annotateSourceURL(content, pkg, path);
    dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator);
    module = {
      path: dirname,
      exports: {}
    };
    context = {
      require: generateRequireFn(pkg, module),
      global: global,
      module: module,
      exports: module.exports,
      PACKAGE: pkg,
      __filename: path,
      __dirname: dirname
    };
    args = Object.keys(context);
    values = args.map(function(name) {
      return context[name];
    });
    Function.apply(null, __slice.call(args).concat([program])).apply(module, values);
    return module;
  };

  isPackage = function(path) {
    if (!(startsWith(path, fileSeparator) || startsWith(path, "." + fileSeparator) || startsWith(path, ".." + fileSeparator))) {
      return path.split(fileSeparator)[0];
    } else {
      return false;
    }
  };

  generateRequireFn = function(pkg, module) {
    var fn;
    if (module == null) {
      module = rootModule;
    }
    if (pkg.name == null) {
      pkg.name = "ROOT";
    }
    if (pkg.scopedName == null) {
      pkg.scopedName = "ROOT";
    }
    fn = function(path) {
      var otherPackage;
      if (typeof path === "object") {
        return loadPackage(path);
      } else if (isPackage(path)) {
        if (!(otherPackage = pkg.dependencies[path])) {
          throw "Package: " + path + " not found.";
        }
        if (otherPackage.name == null) {
          otherPackage.name = path;
        }
        if (otherPackage.scopedName == null) {
          otherPackage.scopedName = "" + pkg.scopedName + ":" + path;
        }
        return loadPackage(otherPackage);
      } else {
        return loadPath(module, pkg, path);
      }
    };
    fn.packageWrapper = publicAPI.packageWrapper;
    fn.executePackageWrapper = publicAPI.executePackageWrapper;
    return fn;
  };

  publicAPI = {
    generateFor: generateRequireFn,
    packageWrapper: function(pkg, code) {
      return ";(function(PACKAGE) {\n  var src = " + (JSON.stringify(PACKAGE.distribution.main.content)) + ";\n  var Require = new Function(\"PACKAGE\", \"return \" + src)({distribution: {main: {content: src}}});\n  var require = Require.generateFor(PACKAGE);\n  " + code + ";\n})(" + (JSON.stringify(pkg, null, 2)) + ");";
    },
    executePackageWrapper: function(pkg) {
      return publicAPI.packageWrapper(pkg, "require('./" + pkg.entryPoint + "')");
    },
    loadPackage: loadPackage
  };

  if (typeof exports !== "undefined" && exports !== null) {
    module.exports = publicAPI;
  } else {
    global.Require = publicAPI;
  }

  startsWith = function(string, prefix) {
    return string.lastIndexOf(prefix, 0) === 0;
  };

  cacheFor = function(pkg) {
    if (pkg.cache) {
      return pkg.cache;
    }
    Object.defineProperty(pkg, "cache", {
      value: {}
    });
    return pkg.cache;
  };

  annotateSourceURL = function(program, pkg, path) {
    return "" + program + "\n//# sourceURL=" + pkg.scopedName + "/" + path;
  };

  return publicAPI;

}).call(this);

  window.require = Require.generateFor(pkg);
})({
  "source": {
    "README.md": {
      "path": "README.md",
      "content": "# sfxz-edit\nAn editor for sfxz, like jsfxr\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/riffwav.js": {
      "path": "lib/riffwav.js",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Receive data as Uint8Array and return blobs\n *\n */\n\nmodule.exports = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    var wavHeader = Uint8Array.from(this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size)\n    ));\n\n    return new Blob([wavHeader, data], {type: \"audio/wav\"});\n  };\n\n  if (data) this.Make(data);\n\n};\n",
      "mode": "100644",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "content": "styleNode = document.createElement(\"style\")\nstyleNode.innerHTML = require('./style')\ndocument.head.appendChild(styleNode)\n\nEffect = require  \"./models/effect\"\n\nApplicationTemplate = require \"./templates/application\"\nControlsPresenter = require \"./presenters/controls\"\nEffectPresenter = require \"./presenters/effect\"\n\neffect = Effect()\n\ncontrolsElement = ControlsPresenter effect\n\nglobal.audioContext = new AudioContext\n\ncreateAndPlay = (type) ->\n  effect.randomOfType(type)\n  effect.play()\n\ndocument.body.appendChild ApplicationTemplate\n  controlsElement: controlsElement\n  coin: ->\n    createAndPlay(\"pickupCoin\")\n\n  laser: ->\n    createAndPlay(\"laserShoot\")\n\n  explosion: ->\n    createAndPlay(\"explosion\")\n\n  powerUp: ->\n    createAndPlay(\"powerUp\")\n\n  hit: ->\n    createAndPlay(\"hitHurt\")\n\n  jump: ->\n    createAndPlay(\"jump\")\n\n  blip: ->\n    createAndPlay(\"blipSelect\")\n\n  tone: ->\n    createAndPlay(\"tone\")\n\ndocument.body.appendChild EffectPresenter effect\n\ncreateAndPlay(\"laserShoot\")\n",
      "mode": "100644",
      "type": "blob"
    },
    "mutator.js": {
      "path": "mutator.js",
      "content": "var SQUARE = 0,\n  SAWTOOTH = 1,\n  SINE = 2,\n  NOISE = 3;\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\nmodule.exports = {\n  pickupCoin: function (p) {\n    p.freq = 0.4 + frnd(0.5);\n    p.attack = 0;\n    p.sustain = frnd(0.1);\n    p.decay = 0.1 + frnd(0.4);\n    p.punch = 0.3 + frnd(0.3);\n    if (rnd(1)) {\n      p.arpSpeed = 0.5 + frnd(0.2);\n      p.arpMod = 0.2 + frnd(0.4);\n    }\n    return p;\n  },\n  laserShoot: function (p) {\n    p.shape = rnd(2);\n    if(p.shape === SINE && rnd(1))\n      p.shape = rnd(1);\n    if (rnd(2) === 0) {\n      p.freq = 0.3 + frnd(0.6);\n      p.freqLimit = frnd(0.1);\n      p.freqSlide = -0.35 - frnd(0.3);\n    } else {\n      p.freq = 0.5 + frnd(0.5);\n      p.freqLimit = p.freq - 0.2 - frnd(0.6);\n      if (p.freqLimit < 0.2) p.freqLimit = 0.2;\n      p.freqSlide = -0.15 - frnd(0.2);\n    }\n    if (p.shape === SAWTOOTH)\n      p.duty = 1;\n    if (rnd(1)) {\n      p.duty = frnd(0.5);\n      p.dutySweep = frnd(0.2);\n    } else {\n      p.duty = 0.4 + frnd(0.5);\n      p.dutySweep = -frnd(0.7);\n    }\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.2);\n    p.decay = frnd(0.4);\n    if (rnd(1))\n      p.punch = frnd(0.3);\n    if (rnd(2) === 0) {\n      p.flangerOffset = frnd(0.2);\n      p.flangerSweep = -frnd(0.2);\n    }\n    //if (rnd(1))\n      p.hpf = frnd(0.3);\n\n    return p;\n  },\n  explosion: function (p) {\n    p.shape = NOISE;\n    if (rnd(1)) {\n      p.freq = sqr(0.1 + frnd(0.4));\n      p.freqSlide = -0.1 + frnd(0.4);\n    } else {\n      p.freq = sqr(0.2 + frnd(0.7));\n      p.freqSlide = -0.2 - frnd(0.2);\n    }\n    if (rnd(4) === 0)\n      p.freqSlide = 0;\n    if (rnd(2) === 0)\n      p.repeatSpeed = 0.3 + frnd(0.5);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.3);\n    p.decay = frnd(0.5);\n    if (rnd(1)) {\n      p.flangerOffset = -0.3 + frnd(0.9);\n      p.flangerSweep = -frnd(0.3);\n    }\n    p.punch = 0.2 + frnd(0.6);\n    if (rnd(1)) {\n      p.vibDepth = frnd(0.7);\n      p.vibSpeed = frnd(0.6);\n    }\n    if (rnd(2) === 0) {\n      p.arpSpeed = 0.6 + frnd(0.3);\n      p.arpMod = 0.8 - frnd(1.6);\n    }\n  \n    return p;\n  },\n  powerUp: function (p) {\n    if (rnd(1)) {\n      p.shape = SAWTOOTH;\n      p.duty = 1;\n    } else {\n      p.duty = frnd(0.6);\n    }\n    p.freq = 0.2 + frnd(0.3);\n    if (rnd(1)) {\n      p.freqSlide = 0.1 + frnd(0.4);\n      p.repeatSpeed = 0.4 + frnd(0.4);\n    } else {\n      p.freqSlide = 0.05 + frnd(0.2);\n      if (rnd(1)) {\n        p.vibDepth = frnd(0.7);\n        p.vibSpeed = frnd(0.6);\n      }\n    }\n    p.attack = 0;\n    p.sustain = frnd(0.4);\n    p.decay = 0.1 + frnd(0.4);\n  \n    return p;\n  },\n  hitHurt: function (p) {\n    p.shape = rnd(2);\n    if (p.shape === SINE)\n      p.shape = NOISE;\n    if (p.shape === SQUARE)\n      p.duty = frnd(0.6);\n    if (p.shape === SAWTOOTH)\n      p.duty = 1;\n    p.freq = 0.2 + frnd(0.6);\n    p.freqSlide = -0.3 - frnd(0.4);\n    p.attack = 0;\n    p.sustain = frnd(0.1);\n    p.decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n      p.hpf = frnd(0.3);\n    return p;\n  },\n  jump: function (p) {\n    p.shape = SQUARE;\n    p.duty = frnd(0.6);\n    p.freq = 0.3 + frnd(0.3);\n    p.freqSlide = 0.1 + frnd(0.2);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.3);\n    p.decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n      p.hpf = frnd(0.3);\n    if (rnd(1))\n      p.lpf = 1 - frnd(0.6);\n    return p;\n  },\n  blipSelect: function (p) {\n    p.shape = rnd(1);\n    if (p.shape === SQUARE)\n      p.duty = frnd(0.6);\n    else\n      p.duty = 1;\n    p.freq = 0.2 + frnd(0.4);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.1);\n    p.decay = frnd(0.2);\n    p.hpf = 0.1;\n    return p;\n  },\n  tone: function (p) {\n    p.shape = SINE;\n    p.freq = 0.35173364; // 440 Hz\n    p.attack = 0;\n    p.sustain = 0.6641; // 1 sec\n    p.decay = 0;\n    p.punch = 0;\n    return p;\n  },\n  mutate: function (p) {\n    if (rnd(1)) p.freq += frnd(0.1) - 0.05;\n    if (rnd(1)) p.freqSlide += frnd(0.1) - 0.05;\n    if (rnd(1)) p.freqSlideDelta += frnd(0.1) - 0.05;\n    if (rnd(1)) p.duty += frnd(0.1) - 0.05;\n    if (rnd(1)) p.dutySweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.vibDepth += frnd(0.1) - 0.05;\n    if (rnd(1)) p.vibSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.p_vib_delay += frnd(0.1) - 0.05;\n    if (rnd(1)) p.attack += frnd(0.1) - 0.05;\n    if (rnd(1)) p.sustain += frnd(0.1) - 0.05;\n    if (rnd(1)) p.decay += frnd(0.1) - 0.05;\n    if (rnd(1)) p.punch += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpfResonance += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpf += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpfSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.hpf += frnd(0.1) - 0.05;\n    if (rnd(1)) p.hpfSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.flangerOffset += frnd(0.1) - 0.05;\n    if (rnd(1)) p.flangerSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.repeatSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.arpSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.arpMod += frnd(0.1) - 0.05;\n    return p\n  },\n  randomize: function (p) {\n    if (rnd(1))\n      p.freq = cube(frnd(2) - 1) + 0.5;\n    else\n      p.freq = sqr(frnd(1));\n    p.freqLimit = 0;\n    p.freqSlide = Math.pow(frnd(2) - 1, 5);\n    if (p.freq > 0.7 && p.freqSlide > 0.2)\n      p.freqSlide = -p.freqSlide;\n    if (p.freq < 0.2 && p.freqSlide < -0.05)\n      p.freqSlide = -p.freqSlide;\n    p.freqSlideDelta = Math.pow(frnd(2) - 1, 3);\n    p.duty = frnd(2) - 1;\n    p.dutySweep = Math.pow(frnd(2) - 1, 3);\n    p.vibDepth = Math.pow(frnd(2) - 1, 3);\n    p.vibSpeed = rndr(-1, 1);\n    p.attack = cube(rndr(-1, 1));\n    p.sustain = sqr(rndr(-1, 1));\n    p.decay = rndr(-1, 1);\n    p.punch = Math.pow(frnd(0.8), 2);\n    if (p.attack + p.sustain + p.decay < 0.2) {\n      p.sustain += 0.2 + frnd(0.3);\n      p.decay += 0.2 + frnd(0.3);\n    }\n    p.lpfResonance = rndr(-1, 1);\n    p.lpf = 1 - Math.pow(frnd(1), 3);\n    p.lpfSweep = Math.pow(frnd(2) - 1, 3);\n    if (p.lpf < 0.1 && p.lpfSweep < -0.05)\n      p.lpfSweep = -p.lpfSweep;\n    p.hpf = Math.pow(frnd(1), 5);\n    p.hpfSweep = Math.pow(frnd(2) - 1, 5);\n    p.flangerOffset = Math.pow(frnd(2) - 1, 3);\n    p.flangerSweep = Math.pow(frnd(2) - 1, 3);\n    p.repeatSpeed = frnd(2) - 1;\n    p.arpSpeed = frnd(2) - 1;\n    p.arpMod = frnd(2) - 1;\n    return p;\n  },\n  reset: function(p) {\n    p.shape = 0;\n\n    // Envelope\n    p.attack = 0;    // Attack time\n    p.sustain = 0.3; // Sustain time\n    p.punch = 0;     // Sustain punch\n    p.decay = 0.4;   // Decay time\n\n    // Tone\n    p.freq = 0.3;    // Start frequency\n    p.freqLimit = 0;   // Min frequency cutoff\n    p.freqSlide = 0;    // Slide (SIGNED)\n    p.freqSlideDelta = 0;   // Delta slide (SIGNED)\n    // Vibrato\n    p.vibDepth = 0; // Vibrato depth\n    p.vibSpeed = 0;    // Vibrato speed\n\n    // Tonal change\n    p.arpMod = 0;      // Change amount (SIGNED)\n    p.arpSpeed = 0;    // Change speed\n\n    // Square wave duty (proportion of time signal is high vs. low)\n    p.duty = 0;         // Square duty\n    p.dutySweep = 0;    // Duty sweep (SIGNED)\n\n    // Repeat\n    p.repeatSpeed = 0; // Repeat speed\n\n    // Flanger\n    p.flangerOffset = 0;   // Flanger offset (SIGNED)\n    p.flangerSweep = 0;     // Flanger sweep (SIGNED)\n\n    // Low-pass filter\n    p.lpf = 1;     // Low-pass filter cutoff\n    p.lpfSweep = 0;     // Low-pass filter cutoff sweep (SIGNED)\n    p.lpfResonance = 0;// Low-pass filter resonance\n    // High-pass filter\n    p.hpf = 0;     // High-pass filter cutoff\n    p.hpfSweep = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n    // Sample parameters\n    p.vol = 0.5;\n\n    return p;\n  }\n};\n",
      "mode": "100644",
      "type": "blob"
    },
    "old/demo.js": {
      "path": "old/demo.js",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar vol = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.vol = vol;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.shape == SQUARE || PARAMS.shape == SAWTOOTH;\n  $(\"#duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#dutySweep\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"shape\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.shape = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    freq:  'Hz',\n    freqLimit: 'Hz',\n    freqSlide:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    freqSlideDelta: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    vibSpeed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    vibDepth: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    arpMod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    arpSpeed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    dutySweep: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    repeatSpeed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    flangerOffset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    flangerSweep:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    lpf:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    lpfSweep:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    lpfResonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    hpf:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    hpfSweep: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    attack:  function (v) { return v * v * 100000.0 },\n    sustain: function (v) { return v * v * 100000.0 },\n    punch:   function (v) { return v },\n    decay:   function (v) { return v * v * 100000.0 },\n\n    freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    freqLimit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    freqSlide:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    freqSlideDelta: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    vibSpeed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    vibDepth: function (v) { return v * 0.5 },\n\n    arpMod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    arpSpeed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    duty:      function (v) { return 0.5 - v * 0.5; },\n    dutySweep: function (v) { return -v * 0.00005 },\n\n    repeatSpeed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    flangerOffset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    flangerSweep:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    lpf:   function (v) { return Math.pow(v, 3) * 0.1 },\n    lpfSweep:   function (v) { return 1.0 + v * 0.0001 },\n    lpfResonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    hpf: function (v) { return Math.pow(v, 2) * 0.1 },\n    hpfSweep: function (v) { return 1.0 + v * 0.0003 },\n\n    vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "mode": "100644",
      "type": "blob"
    },
    "old/knobs.js": {
      "path": "old/knobs.js",
      "content": "// Dumping this duplicat stuff in here for now\n\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.shape;\n\n  this.attack = sqr(ps.attack) * 100000 / 44100;\n  this.sustain = sqr(ps.sustain) * 100000 / 44100;\n  this.punch = ps.punch;\n  this.decay = sqr(ps.decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.freq) + 0.001);\n  if (ps.freqLimit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.freqLimit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.freqLimit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.freqSlide) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.freqSlideDelta) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.vibSpeed) / 100;\n  this.vibratoDepth = ps.vibDepth / 2;\n\n  this.arpeggioFactor = 1 / ((ps.arpMod >= 0) ?\n                             1 - sqr(ps.arpMod) * 0.9 :\n                             1 + sqr(ps.arpMod) * 10);\n  this.arpeggioDelay = ((ps.arpSpeed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.arpSpeed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.dutySweep / 20000;\n\n  this.retriggerRate = 44100 / ((ps.repeatSpeed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.repeatSpeed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.flangerOffset) *\n    sqr(ps.flangerOffset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.flangerSweep) * sqr(ps.flangerSweep);\n\n  this.enableLowPassFilter = (ps.lpf != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.lpf === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.lpf) / 10));\n  this.lowPassSweep = pow(1 + ps.lpfSweep / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.lpfResonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.hpf) / 10));\n  this.highPassSweep = pow(1 + ps.hpfSweep * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n",
      "mode": "100644",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "content": "name: \"SFXZ Edit\"\nversion: \"0.1.0\"\ndependencies:\n  sfxz: \"STRd6/sfxz:v0.3.1\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "presenters/controls.coffee": {
      "path": "presenters/controls.coffee",
      "content": "ControlTemplate = require \"../templates/control\"\n# Pull in bundled Observable from editor\n{Observable} = require \"/lib/jadelet-runtime\"\n\ncontrolGroups =\n  Wave:\n    shape:\n      name: \"Shape\"\n  Envelope:\n    attack:\n      name: \"Attack\"\n    sustain:\n      name: \"Sustain\"\n    punch:\n      name: \"Sustain Punch\"\n    decay:\n      name: \"Decay\"\n  Frequency:\n    freq:\n      name: \"Frequency\"\n    freqLimit:\n      name: \"Min Freq Cutoff\"\n    freqSlide:\n      name: \"Frequency Slide\"\n      signed: true\n    freqSlideDelta:\n      name: \"Frequency Slide Δ\"\n      signed: true\n  Vibrato:\n    vibDepth:\n      name: \"Vibrato Depth\"\n    vibSpeed:\n      name: \"Vibrato Speed\"\n  Arpeggiation:\n    arpMod:\n      name: \"Frequency Mult\"\n      signed: true\n    arpSpeed:\n      name: \"Time\"\n  \"Duty Cycle\":\n    duty:\n      name: \"Duty Cycle\"\n    dutySweep:\n      name: \"Sweep\"\n      signed: true\n  Retrigger:\n    repeatSpeed:\n      name: \"Rate\"\n  Flanger:\n    flangerOffset:\n      name: \"Offset\"\n      signed: true\n    flangerSweep:\n      name: \"Sweep\"\n      signed: true\n  \"Low-Pass Filter\":\n    lpf:\n      name: \"Cutoff Freq\"\n    lpfSweep:\n      name: \"Cutoff Sweep\"\n      signed: true\n    lpfResonance:\n      name: \"Resonance\"\n  \"High-Pass Filter\":\n    hpf:\n      name: \"Cutoff Freq\"\n    hpfSweep:\n      name: \"Cutoff Sweep\"\n      signed: true\n\nSection = (className) ->\n  element = document.createElement \"section\"\n  element.classList.add className\n\n  return element\n\nH2 = (text) ->\n  h2 = document.createElement \"h2\"\n  h2.innerText = text\n\n  return h2\n\nmodule.exports = (effect) ->\n  element = Section(\"controls\")\n\n  params = effect.params()\n\n  observableProps = {}\n\n  Object.keys(controlGroups).map (groupName) ->\n    group = controlGroups[groupName]\n\n    groupElement = Section(\"group\")\n    groupElement.appendChild H2 groupName\n    element.appendChild groupElement\n\n    Object.keys(group).map (property) ->\n      {name, signed} = group[property]\n\n      if signed\n        min = -1\n      else\n        min = 0\n\n      step = 0.001\n      max = 1\n\n      value = observableProps[property] = Observable params[property]\n      value.observe (newValue) ->\n        params[property] = newValue\n\n      groupElement.appendChild ControlTemplate\n        name: name\n        value: value\n        min: min\n        max: max\n        step: step\n        input: ->\n          effect.regenerate()\n          unless effect.playing()\n            effect.play()\n\n  effect.on \"update\", ->\n    Object.keys(params).forEach (name) ->\n      observableProps[name]?(params[name])\n\n  return element\n",
      "mode": "100644",
      "type": "blob"
    },
    "style.styl": {
      "path": "style.styl",
      "content": "*\n  box-sizing: border-box\n\nbody\n  font-family: \"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif\n  font-size: 16px\n  font-weight: 300\n  margin: 0\n\n  > application\n    display: block\n\nh2\n  font-size: 1em\n  margin: 0\n\ndiv.effect\n  > div.actions\n    > a\n      padding: 0 1em\n  > canvas\n    display: block\n\nsection.generators\n  display: flex\n  > button\n    flex: 1\n\nsection.controls\n  display: flex\n  flex-wrap: wrap\n\nsection.group\n  > h2\n    font-size: 12px\n\nsection.control\n  align-items: center\n  display: flex\n  position: relative\n\n  > label\n    position: absolute\n    pointer-events: none\n    font-size: 12px\n    right: 3px\n    top: -4px\n    z-index: -1\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/application.jadelet": {
      "path": "templates/application.jadelet",
      "content": "application\n  section.generators\n    button(click=@coin) Coin\n    button(click=@laser) Laser\n    button(click=@explosion) Explosion\n    button(click=@powerUp) Power Up\n    button(click=@hit) Hit\n    button(click=@jump) Jump\n    button(click=@blip) Blip\n    button(click=@tone) Tone\n\n  = @controlsElement\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/control.jadelet": {
      "path": "templates/control.jadelet",
      "content": "section.control\n  input(type=\"range\" @min @max @step @value @input)\n  - #input(type=\"number\" @min @max @step @value @input)\n  label= @name\n",
      "mode": "100644",
      "type": "blob"
    },
    "spectrum.coffee": {
      "path": "spectrum.coffee",
      "content": "module.exports = (buffer, canvas, displayWidth) ->\n  sampleRate = 44100\n  xScale = displayWidth / buffer.length\n  width = displayWidth\n  height = 200\n\n  canvas.width = width\n  canvas.height = height\n\n  context = canvas.getContext('2d')\n\n  context.fillStyle = \"black\"\n  context.fillRect(0, 0, width, height)\n\n  context.lineWidth = 2\n  context.strokeStyle = \"#F00\"\n\n  # Plot time domain\n  buffer.forEach (value, index) ->\n    x = index * xScale\n    y = height * (value + 1) / 2\n\n    if index is 0\n      context.beginPath()\n      context.moveTo x, y\n    else\n      context.lineTo x, y\n\n  context.stroke()\n\n  # Plot time markers\n  context.lineWidth = 1\n  context.fillStyle = \"rgba(255, 255, 255, 0.75)\"\n\n  marksPerSecond = 16\n\n  numberOfMarks = buffer.length / (sampleRate / marksPerSecond)\n  n = 0\n  while n < numberOfMarks\n    n += 1\n    t = n / marksPerSecond\n    x = t * xScale * sampleRate\n    context.fillRect(x, 0, 1, height)\n    context.fillText(\"#{t}\", x + 6, 12)\n\n  return canvas\n",
      "mode": "100644"
    },
    "templates/effect.jadelet": {
      "path": "templates/effect.jadelet",
      "content": ".effect\n  .actions\n    button(click=@play) ▶ Play\n    a(href=@wavURL download=@wavFilename) Download .wav\n    a(href=@sfxzURL download=@sfxzFilename) Download .sfxz\n  = @canvas\n",
      "mode": "100644"
    },
    "models/effect.coffee": {
      "path": "models/effect.coffee",
      "content": "# Pull in bundled Observable from editor\n{Observable} = require \"/lib/jadelet-runtime\"\n\nWav = require \"../lib/wav\"\n\n{Params, Serializer} = SFXZ = require \"sfxz\"\n\nMutator = require \"../mutator\"\n\nmodule.exports = ->\n  params = new Params\n\n  audioBuffer = null\n  sfxzBlob = null\n\n  updateSfxzURL = ->\n    oldURL = self.sfxzURL()\n\n    if oldURL\n      URL.revokeObjectURL(oldURL)\n\n    sfxzBuffer = Serializer.serialize(params)\n    sfxzBlob = new Blob [sfxzBuffer],\n      type: \"application/sfxz\"\n\n    self.sfxzURL URL.createObjectURL(sfxzBlob)\n  \n  updateWavURL = ->\n    oldURL = self.wavURL()\n\n    if oldURL\n      URL.revokeObjectURL(oldURL)\n\n    wavFile = Wav(self.samples())\n    self.wavURL URL.createObjectURL(wavFile)\n\n  listeners = {}\n\n  self =\n    regenerate: ->\n      # Generate audio data\n      audioBuffer = SFXZ(params, audioContext)\n\n      updateSfxzURL()\n      updateWavURL()\n\n      self.trigger \"update\"\n\n    randomOfType: (type) ->\n      params = Mutator[type](Mutator.reset(params))\n\n      self.regenerate()\n\n    params: ->\n      params\n\n    samples: ->\n      audioBuffer.getChannelData(0)\n\n    wavFilename: \"sound.wav\"\n    wavURL: Observable null\n\n    sfxzFilename: \"sound.sfxz\"\n    sfxzURL: Observable null\n\n    playing: Observable false\n\n    play: ->\n      # Play buffer\n      node = new AudioBufferSourceNode audioContext,\n        buffer: audioBuffer\n      node.connect audioContext.destination\n      node.addEventListener \"ended\", (e) ->\n        console.log \"Ended\", e\n        self.playing(false)\n\n      self.playing true\n      node.start()\n\n    on: (type, listener) ->\n      listeners[type] ?= []\n      listeners[type].push listener\n\n      return self\n\n    trigger: (type, args...) ->\n      listeners[type]?.forEach (listener) ->\n        listener.apply(self, args...)\n\n  return self\n",
      "mode": "100644"
    },
    "lib/wav.coffee": {
      "path": "lib/wav.coffee",
      "content": "RIFFWAVE = require \"./riffwav\"\n\ncreateWavData = (samples, eightBit=false) ->\n  if eightBit\n    bitsPerSample = 8\n    buffer = new Uint8Array(samples.length)\n  else\n    bitsPerSample = 16\n    buffer = new Uint8Array(samples.length * 2)  \n\n  clipCount = 0\n\n  samples.forEach (sample, i) ->\n    if eightBit\n      # Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128)\n      if sample > 255\n        sample = 255\n        ++clipCount\n      else if sample < 0\n        sample = 0\n        ++clipCount\n\n      buffer[i] = sample\n    else\n      # Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15))\n      if sample >= (1<<15)\n        sample = (1 << 15)-1\n        ++clipCount\n      else if sample < -(1<<15)\n        sample = -(1 << 15)\n        ++clipCount\n\n      buffer[2 * i] = sample & 0xFF\n      buffer[2 * i + 1] = (sample >> 8) & 0xFF\n\n  buffer: buffer\n  clipCount: clipCount\n  bitsPerSample: bitsPerSample\n\nmodule.exports = (samples, sampleRate=44100) ->\n  {buffer, clipCount, bitsPerSample} = createWavData(samples)\n\n  wave = new RIFFWAVE()\n  wave.header.sampleRate = sampleRate\n  wave.header.bitsPerSample = bitsPerSample\n\n  return wave.Make(buffer)\n",
      "mode": "100644"
    },
    "presenters/effect.coffee": {
      "path": "presenters/effect.coffee",
      "content": "EffectTemplate = require \"../templates/effect\"\nSpectrum = require \"../spectrum\"\n\nmodule.exports = (effect) ->\n  effect.on \"update\", ->\n    Spectrum(effect.samples(), timeDomainCanvas, element.clientWidth)\n\n  timeDomainCanvas = document.createElement 'canvas'\n\n  effect.canvas = timeDomainCanvas\n\n  element = EffectTemplate effect\n\n  return element\n",
      "mode": "100644"
    }
  },
  "distribution": {
    "lib/riffwav": {
      "path": "lib/riffwav",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Receive data as Uint8Array and return blobs\n *\n */\n\nmodule.exports = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    var wavHeader = Uint8Array.from(this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size)\n    ));\n\n    return new Blob([wavHeader, data], {type: \"audio/wav\"});\n  };\n\n  if (data) this.Make(data);\n\n};\n",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  var ApplicationTemplate, ControlsPresenter, Effect, EffectPresenter, controlsElement, createAndPlay, effect, styleNode;\n\n  styleNode = document.createElement(\"style\");\n\n  styleNode.innerHTML = require('./style');\n\n  document.head.appendChild(styleNode);\n\n  Effect = require(\"./models/effect\");\n\n  ApplicationTemplate = require(\"./templates/application\");\n\n  ControlsPresenter = require(\"./presenters/controls\");\n\n  EffectPresenter = require(\"./presenters/effect\");\n\n  effect = Effect();\n\n  controlsElement = ControlsPresenter(effect);\n\n  global.audioContext = new AudioContext;\n\n  createAndPlay = function(type) {\n    effect.randomOfType(type);\n    return effect.play();\n  };\n\n  document.body.appendChild(ApplicationTemplate({\n    controlsElement: controlsElement,\n    coin: function() {\n      return createAndPlay(\"pickupCoin\");\n    },\n    laser: function() {\n      return createAndPlay(\"laserShoot\");\n    },\n    explosion: function() {\n      return createAndPlay(\"explosion\");\n    },\n    powerUp: function() {\n      return createAndPlay(\"powerUp\");\n    },\n    hit: function() {\n      return createAndPlay(\"hitHurt\");\n    },\n    jump: function() {\n      return createAndPlay(\"jump\");\n    },\n    blip: function() {\n      return createAndPlay(\"blipSelect\");\n    },\n    tone: function() {\n      return createAndPlay(\"tone\");\n    }\n  }));\n\n  document.body.appendChild(EffectPresenter(effect));\n\n  createAndPlay(\"laserShoot\");\n\n}).call(this);\n",
      "type": "blob"
    },
    "mutator": {
      "path": "mutator",
      "content": "var SQUARE = 0,\n  SAWTOOTH = 1,\n  SINE = 2,\n  NOISE = 3;\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\nmodule.exports = {\n  pickupCoin: function (p) {\n    p.freq = 0.4 + frnd(0.5);\n    p.attack = 0;\n    p.sustain = frnd(0.1);\n    p.decay = 0.1 + frnd(0.4);\n    p.punch = 0.3 + frnd(0.3);\n    if (rnd(1)) {\n      p.arpSpeed = 0.5 + frnd(0.2);\n      p.arpMod = 0.2 + frnd(0.4);\n    }\n    return p;\n  },\n  laserShoot: function (p) {\n    p.shape = rnd(2);\n    if(p.shape === SINE && rnd(1))\n      p.shape = rnd(1);\n    if (rnd(2) === 0) {\n      p.freq = 0.3 + frnd(0.6);\n      p.freqLimit = frnd(0.1);\n      p.freqSlide = -0.35 - frnd(0.3);\n    } else {\n      p.freq = 0.5 + frnd(0.5);\n      p.freqLimit = p.freq - 0.2 - frnd(0.6);\n      if (p.freqLimit < 0.2) p.freqLimit = 0.2;\n      p.freqSlide = -0.15 - frnd(0.2);\n    }\n    if (p.shape === SAWTOOTH)\n      p.duty = 1;\n    if (rnd(1)) {\n      p.duty = frnd(0.5);\n      p.dutySweep = frnd(0.2);\n    } else {\n      p.duty = 0.4 + frnd(0.5);\n      p.dutySweep = -frnd(0.7);\n    }\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.2);\n    p.decay = frnd(0.4);\n    if (rnd(1))\n      p.punch = frnd(0.3);\n    if (rnd(2) === 0) {\n      p.flangerOffset = frnd(0.2);\n      p.flangerSweep = -frnd(0.2);\n    }\n    //if (rnd(1))\n      p.hpf = frnd(0.3);\n\n    return p;\n  },\n  explosion: function (p) {\n    p.shape = NOISE;\n    if (rnd(1)) {\n      p.freq = sqr(0.1 + frnd(0.4));\n      p.freqSlide = -0.1 + frnd(0.4);\n    } else {\n      p.freq = sqr(0.2 + frnd(0.7));\n      p.freqSlide = -0.2 - frnd(0.2);\n    }\n    if (rnd(4) === 0)\n      p.freqSlide = 0;\n    if (rnd(2) === 0)\n      p.repeatSpeed = 0.3 + frnd(0.5);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.3);\n    p.decay = frnd(0.5);\n    if (rnd(1)) {\n      p.flangerOffset = -0.3 + frnd(0.9);\n      p.flangerSweep = -frnd(0.3);\n    }\n    p.punch = 0.2 + frnd(0.6);\n    if (rnd(1)) {\n      p.vibDepth = frnd(0.7);\n      p.vibSpeed = frnd(0.6);\n    }\n    if (rnd(2) === 0) {\n      p.arpSpeed = 0.6 + frnd(0.3);\n      p.arpMod = 0.8 - frnd(1.6);\n    }\n  \n    return p;\n  },\n  powerUp: function (p) {\n    if (rnd(1)) {\n      p.shape = SAWTOOTH;\n      p.duty = 1;\n    } else {\n      p.duty = frnd(0.6);\n    }\n    p.freq = 0.2 + frnd(0.3);\n    if (rnd(1)) {\n      p.freqSlide = 0.1 + frnd(0.4);\n      p.repeatSpeed = 0.4 + frnd(0.4);\n    } else {\n      p.freqSlide = 0.05 + frnd(0.2);\n      if (rnd(1)) {\n        p.vibDepth = frnd(0.7);\n        p.vibSpeed = frnd(0.6);\n      }\n    }\n    p.attack = 0;\n    p.sustain = frnd(0.4);\n    p.decay = 0.1 + frnd(0.4);\n  \n    return p;\n  },\n  hitHurt: function (p) {\n    p.shape = rnd(2);\n    if (p.shape === SINE)\n      p.shape = NOISE;\n    if (p.shape === SQUARE)\n      p.duty = frnd(0.6);\n    if (p.shape === SAWTOOTH)\n      p.duty = 1;\n    p.freq = 0.2 + frnd(0.6);\n    p.freqSlide = -0.3 - frnd(0.4);\n    p.attack = 0;\n    p.sustain = frnd(0.1);\n    p.decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n      p.hpf = frnd(0.3);\n    return p;\n  },\n  jump: function (p) {\n    p.shape = SQUARE;\n    p.duty = frnd(0.6);\n    p.freq = 0.3 + frnd(0.3);\n    p.freqSlide = 0.1 + frnd(0.2);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.3);\n    p.decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n      p.hpf = frnd(0.3);\n    if (rnd(1))\n      p.lpf = 1 - frnd(0.6);\n    return p;\n  },\n  blipSelect: function (p) {\n    p.shape = rnd(1);\n    if (p.shape === SQUARE)\n      p.duty = frnd(0.6);\n    else\n      p.duty = 1;\n    p.freq = 0.2 + frnd(0.4);\n    p.attack = 0;\n    p.sustain = 0.1 + frnd(0.1);\n    p.decay = frnd(0.2);\n    p.hpf = 0.1;\n    return p;\n  },\n  tone: function (p) {\n    p.shape = SINE;\n    p.freq = 0.35173364; // 440 Hz\n    p.attack = 0;\n    p.sustain = 0.6641; // 1 sec\n    p.decay = 0;\n    p.punch = 0;\n    return p;\n  },\n  mutate: function (p) {\n    if (rnd(1)) p.freq += frnd(0.1) - 0.05;\n    if (rnd(1)) p.freqSlide += frnd(0.1) - 0.05;\n    if (rnd(1)) p.freqSlideDelta += frnd(0.1) - 0.05;\n    if (rnd(1)) p.duty += frnd(0.1) - 0.05;\n    if (rnd(1)) p.dutySweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.vibDepth += frnd(0.1) - 0.05;\n    if (rnd(1)) p.vibSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.p_vib_delay += frnd(0.1) - 0.05;\n    if (rnd(1)) p.attack += frnd(0.1) - 0.05;\n    if (rnd(1)) p.sustain += frnd(0.1) - 0.05;\n    if (rnd(1)) p.decay += frnd(0.1) - 0.05;\n    if (rnd(1)) p.punch += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpfResonance += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpf += frnd(0.1) - 0.05;\n    if (rnd(1)) p.lpfSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.hpf += frnd(0.1) - 0.05;\n    if (rnd(1)) p.hpfSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.flangerOffset += frnd(0.1) - 0.05;\n    if (rnd(1)) p.flangerSweep += frnd(0.1) - 0.05;\n    if (rnd(1)) p.repeatSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.arpSpeed += frnd(0.1) - 0.05;\n    if (rnd(1)) p.arpMod += frnd(0.1) - 0.05;\n    return p\n  },\n  randomize: function (p) {\n    if (rnd(1))\n      p.freq = cube(frnd(2) - 1) + 0.5;\n    else\n      p.freq = sqr(frnd(1));\n    p.freqLimit = 0;\n    p.freqSlide = Math.pow(frnd(2) - 1, 5);\n    if (p.freq > 0.7 && p.freqSlide > 0.2)\n      p.freqSlide = -p.freqSlide;\n    if (p.freq < 0.2 && p.freqSlide < -0.05)\n      p.freqSlide = -p.freqSlide;\n    p.freqSlideDelta = Math.pow(frnd(2) - 1, 3);\n    p.duty = frnd(2) - 1;\n    p.dutySweep = Math.pow(frnd(2) - 1, 3);\n    p.vibDepth = Math.pow(frnd(2) - 1, 3);\n    p.vibSpeed = rndr(-1, 1);\n    p.attack = cube(rndr(-1, 1));\n    p.sustain = sqr(rndr(-1, 1));\n    p.decay = rndr(-1, 1);\n    p.punch = Math.pow(frnd(0.8), 2);\n    if (p.attack + p.sustain + p.decay < 0.2) {\n      p.sustain += 0.2 + frnd(0.3);\n      p.decay += 0.2 + frnd(0.3);\n    }\n    p.lpfResonance = rndr(-1, 1);\n    p.lpf = 1 - Math.pow(frnd(1), 3);\n    p.lpfSweep = Math.pow(frnd(2) - 1, 3);\n    if (p.lpf < 0.1 && p.lpfSweep < -0.05)\n      p.lpfSweep = -p.lpfSweep;\n    p.hpf = Math.pow(frnd(1), 5);\n    p.hpfSweep = Math.pow(frnd(2) - 1, 5);\n    p.flangerOffset = Math.pow(frnd(2) - 1, 3);\n    p.flangerSweep = Math.pow(frnd(2) - 1, 3);\n    p.repeatSpeed = frnd(2) - 1;\n    p.arpSpeed = frnd(2) - 1;\n    p.arpMod = frnd(2) - 1;\n    return p;\n  },\n  reset: function(p) {\n    p.shape = 0;\n\n    // Envelope\n    p.attack = 0;    // Attack time\n    p.sustain = 0.3; // Sustain time\n    p.punch = 0;     // Sustain punch\n    p.decay = 0.4;   // Decay time\n\n    // Tone\n    p.freq = 0.3;    // Start frequency\n    p.freqLimit = 0;   // Min frequency cutoff\n    p.freqSlide = 0;    // Slide (SIGNED)\n    p.freqSlideDelta = 0;   // Delta slide (SIGNED)\n    // Vibrato\n    p.vibDepth = 0; // Vibrato depth\n    p.vibSpeed = 0;    // Vibrato speed\n\n    // Tonal change\n    p.arpMod = 0;      // Change amount (SIGNED)\n    p.arpSpeed = 0;    // Change speed\n\n    // Square wave duty (proportion of time signal is high vs. low)\n    p.duty = 0;         // Square duty\n    p.dutySweep = 0;    // Duty sweep (SIGNED)\n\n    // Repeat\n    p.repeatSpeed = 0; // Repeat speed\n\n    // Flanger\n    p.flangerOffset = 0;   // Flanger offset (SIGNED)\n    p.flangerSweep = 0;     // Flanger sweep (SIGNED)\n\n    // Low-pass filter\n    p.lpf = 1;     // Low-pass filter cutoff\n    p.lpfSweep = 0;     // Low-pass filter cutoff sweep (SIGNED)\n    p.lpfResonance = 0;// Low-pass filter resonance\n    // High-pass filter\n    p.hpf = 0;     // High-pass filter cutoff\n    p.hpfSweep = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n    // Sample parameters\n    p.vol = 0.5;\n\n    return p;\n  }\n};\n",
      "type": "blob"
    },
    "old/demo": {
      "path": "old/demo",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar vol = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.vol = vol;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.shape == SQUARE || PARAMS.shape == SAWTOOTH;\n  $(\"#duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#dutySweep\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"shape\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.shape = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    freq:  'Hz',\n    freqLimit: 'Hz',\n    freqSlide:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    freqSlideDelta: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    vibSpeed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    vibDepth: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    arpMod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    arpSpeed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    dutySweep: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    repeatSpeed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    flangerOffset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    flangerSweep:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    lpf:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    lpfSweep:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    lpfResonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    hpf:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    hpfSweep: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    attack:  function (v) { return v * v * 100000.0 },\n    sustain: function (v) { return v * v * 100000.0 },\n    punch:   function (v) { return v },\n    decay:   function (v) { return v * v * 100000.0 },\n\n    freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    freqLimit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    freqSlide:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    freqSlideDelta: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    vibSpeed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    vibDepth: function (v) { return v * 0.5 },\n\n    arpMod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    arpSpeed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    duty:      function (v) { return 0.5 - v * 0.5; },\n    dutySweep: function (v) { return -v * 0.00005 },\n\n    repeatSpeed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    flangerOffset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    flangerSweep:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    lpf:   function (v) { return Math.pow(v, 3) * 0.1 },\n    lpfSweep:   function (v) { return 1.0 + v * 0.0001 },\n    lpfResonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    hpf: function (v) { return Math.pow(v, 2) * 0.1 },\n    hpfSweep: function (v) { return 1.0 + v * 0.0003 },\n\n    vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "type": "blob"
    },
    "old/knobs": {
      "path": "old/knobs",
      "content": "// Dumping this duplicat stuff in here for now\n\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.shape;\n\n  this.attack = sqr(ps.attack) * 100000 / 44100;\n  this.sustain = sqr(ps.sustain) * 100000 / 44100;\n  this.punch = ps.punch;\n  this.decay = sqr(ps.decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.freq) + 0.001);\n  if (ps.freqLimit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.freqLimit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.freqLimit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.freqSlide) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.freqSlideDelta) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.vibSpeed) / 100;\n  this.vibratoDepth = ps.vibDepth / 2;\n\n  this.arpeggioFactor = 1 / ((ps.arpMod >= 0) ?\n                             1 - sqr(ps.arpMod) * 0.9 :\n                             1 + sqr(ps.arpMod) * 10);\n  this.arpeggioDelay = ((ps.arpSpeed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.arpSpeed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.dutySweep / 20000;\n\n  this.retriggerRate = 44100 / ((ps.repeatSpeed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.repeatSpeed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.flangerOffset) *\n    sqr(ps.flangerOffset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.flangerSweep) * sqr(ps.flangerSweep);\n\n  this.enableLowPassFilter = (ps.lpf != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.lpf === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.lpf) / 10));\n  this.lowPassSweep = pow(1 + ps.lpfSweep / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.lpfResonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.hpf) / 10));\n  this.highPassSweep = pow(1 + ps.hpfSweep * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"name\":\"SFXZ Edit\",\"version\":\"0.1.0\",\"dependencies\":{\"sfxz\":\"STRd6/sfxz:v0.3.1\"}};",
      "type": "blob"
    },
    "presenters/controls": {
      "path": "presenters/controls",
      "content": "(function() {\n  var ControlTemplate, H2, Observable, Section, controlGroups;\n\n  ControlTemplate = require(\"../templates/control\");\n\n  Observable = require(\"/lib/jadelet-runtime\").Observable;\n\n  controlGroups = {\n    Wave: {\n      shape: {\n        name: \"Shape\"\n      }\n    },\n    Envelope: {\n      attack: {\n        name: \"Attack\"\n      },\n      sustain: {\n        name: \"Sustain\"\n      },\n      punch: {\n        name: \"Sustain Punch\"\n      },\n      decay: {\n        name: \"Decay\"\n      }\n    },\n    Frequency: {\n      freq: {\n        name: \"Frequency\"\n      },\n      freqLimit: {\n        name: \"Min Freq Cutoff\"\n      },\n      freqSlide: {\n        name: \"Frequency Slide\",\n        signed: true\n      },\n      freqSlideDelta: {\n        name: \"Frequency Slide Δ\",\n        signed: true\n      }\n    },\n    Vibrato: {\n      vibDepth: {\n        name: \"Vibrato Depth\"\n      },\n      vibSpeed: {\n        name: \"Vibrato Speed\"\n      }\n    },\n    Arpeggiation: {\n      arpMod: {\n        name: \"Frequency Mult\",\n        signed: true\n      },\n      arpSpeed: {\n        name: \"Time\"\n      }\n    },\n    \"Duty Cycle\": {\n      duty: {\n        name: \"Duty Cycle\"\n      },\n      dutySweep: {\n        name: \"Sweep\",\n        signed: true\n      }\n    },\n    Retrigger: {\n      repeatSpeed: {\n        name: \"Rate\"\n      }\n    },\n    Flanger: {\n      flangerOffset: {\n        name: \"Offset\",\n        signed: true\n      },\n      flangerSweep: {\n        name: \"Sweep\",\n        signed: true\n      }\n    },\n    \"Low-Pass Filter\": {\n      lpf: {\n        name: \"Cutoff Freq\"\n      },\n      lpfSweep: {\n        name: \"Cutoff Sweep\",\n        signed: true\n      },\n      lpfResonance: {\n        name: \"Resonance\"\n      }\n    },\n    \"High-Pass Filter\": {\n      hpf: {\n        name: \"Cutoff Freq\"\n      },\n      hpfSweep: {\n        name: \"Cutoff Sweep\",\n        signed: true\n      }\n    }\n  };\n\n  Section = function(className) {\n    var element;\n    element = document.createElement(\"section\");\n    element.classList.add(className);\n    return element;\n  };\n\n  H2 = function(text) {\n    var h2;\n    h2 = document.createElement(\"h2\");\n    h2.innerText = text;\n    return h2;\n  };\n\n  module.exports = function(effect) {\n    var element, observableProps, params;\n    element = Section(\"controls\");\n    params = effect.params();\n    observableProps = {};\n    Object.keys(controlGroups).map(function(groupName) {\n      var group, groupElement;\n      group = controlGroups[groupName];\n      groupElement = Section(\"group\");\n      groupElement.appendChild(H2(groupName));\n      element.appendChild(groupElement);\n      return Object.keys(group).map(function(property) {\n        var max, min, name, signed, step, value, _ref;\n        _ref = group[property], name = _ref.name, signed = _ref.signed;\n        if (signed) {\n          min = -1;\n        } else {\n          min = 0;\n        }\n        step = 0.001;\n        max = 1;\n        value = observableProps[property] = Observable(params[property]);\n        value.observe(function(newValue) {\n          return params[property] = newValue;\n        });\n        return groupElement.appendChild(ControlTemplate({\n          name: name,\n          value: value,\n          min: min,\n          max: max,\n          step: step,\n          input: function() {\n            effect.regenerate();\n            if (!effect.playing()) {\n              return effect.play();\n            }\n          }\n        }));\n      });\n    });\n    effect.on(\"update\", function() {\n      return Object.keys(params).forEach(function(name) {\n        return typeof observableProps[name] === \"function\" ? observableProps[name](params[name]) : void 0;\n      });\n    });\n    return element;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "style": {
      "path": "style",
      "content": "module.exports = \"* {\\n  box-sizing: border-box;\\n}\\nbody {\\n  font-family: \\\"HelveticaNeue-Light\\\", \\\"Helvetica Neue Light\\\", \\\"Helvetica Neue\\\", Helvetica, Arial, \\\"Lucida Grande\\\", sans-serif;\\n  font-size: 16px;\\n  font-weight: 300;\\n  margin: 0;\\n}\\nbody > application {\\n  display: block;\\n}\\nh2 {\\n  font-size: 1em;\\n  margin: 0;\\n}\\ndiv.effect > div.actions > a {\\n  padding: 0 1em;\\n}\\ndiv.effect > canvas {\\n  display: block;\\n}\\nsection.generators {\\n  display: flex;\\n}\\nsection.generators > button {\\n  flex: 1;\\n}\\nsection.controls {\\n  display: flex;\\n  flex-wrap: wrap;\\n}\\nsection.group > h2 {\\n  font-size: 12px;\\n}\\nsection.control {\\n  align-items: center;\\n  display: flex;\\n  position: relative;\\n}\\nsection.control > label {\\n  position: absolute;\\n  pointer-events: none;\\n  font-size: 12px;\\n  right: 3px;\\n  top: -4px;\\n  z-index: -1;\\n}\\n\";",
      "type": "blob"
    },
    "templates/application": {
      "path": "templates/application",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/jadelet-runtime\")(this);\n    __root.buffer(__root.element(\"application\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"section\", this, {\n        \"class\": [\"generators\"]\n      }, function(__root) {\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.coin\n        }, function(__root) {\n          __root.buffer(\"Coin\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.laser\n        }, function(__root) {\n          __root.buffer(\"Laser\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.explosion\n        }, function(__root) {\n          __root.buffer(\"Explosion\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.powerUp\n        }, function(__root) {\n          __root.buffer(\"Power Up\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.hit\n        }, function(__root) {\n          __root.buffer(\"Hit\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.jump\n        }, function(__root) {\n          __root.buffer(\"Jump\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.blip\n        }, function(__root) {\n          __root.buffer(\"Blip\\n\");\n        }));\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.tone\n        }, function(__root) {\n          __root.buffer(\"Tone\\n\");\n        }));\n      }));\n      __root.buffer(this.controlsElement);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/control": {
      "path": "templates/control",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/jadelet-runtime\")(this);\n    __root.buffer(__root.element(\"section\", this, {\n      \"class\": [\"control\"]\n    }, function(__root) {\n      __root.buffer(__root.element(\"input\", this, {\n        \"type\": \"range\",\n        \"min\": this.min,\n        \"max\": this.max,\n        \"step\": this.step,\n        \"value\": this.value,\n        \"input\": this.input\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(this.name);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "spectrum": {
      "path": "spectrum",
      "content": "(function() {\n  module.exports = function(buffer, canvas, displayWidth) {\n    var context, height, marksPerSecond, n, numberOfMarks, sampleRate, t, width, x, xScale;\n    sampleRate = 44100;\n    xScale = displayWidth / buffer.length;\n    width = displayWidth;\n    height = 200;\n    canvas.width = width;\n    canvas.height = height;\n    context = canvas.getContext('2d');\n    context.fillStyle = \"black\";\n    context.fillRect(0, 0, width, height);\n    context.lineWidth = 2;\n    context.strokeStyle = \"#F00\";\n    buffer.forEach(function(value, index) {\n      var x, y;\n      x = index * xScale;\n      y = height * (value + 1) / 2;\n      if (index === 0) {\n        context.beginPath();\n        return context.moveTo(x, y);\n      } else {\n        return context.lineTo(x, y);\n      }\n    });\n    context.stroke();\n    context.lineWidth = 1;\n    context.fillStyle = \"rgba(255, 255, 255, 0.75)\";\n    marksPerSecond = 16;\n    numberOfMarks = buffer.length / (sampleRate / marksPerSecond);\n    n = 0;\n    while (n < numberOfMarks) {\n      n += 1;\n      t = n / marksPerSecond;\n      x = t * xScale * sampleRate;\n      context.fillRect(x, 0, 1, height);\n      context.fillText(\"\" + t, x + 6, 12);\n    }\n    return canvas;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/effect": {
      "path": "templates/effect",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/jadelet-runtime\")(this);\n    __root.buffer(__root.element(\"div\", this, {\n      \"class\": [\"effect\"]\n    }, function(__root) {\n      __root.buffer(__root.element(\"div\", this, {\n        \"class\": [\"actions\"]\n      }, function(__root) {\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.play\n        }, function(__root) {\n          __root.buffer(\"▶ Play\\n\");\n        }));\n        __root.buffer(__root.element(\"a\", this, {\n          \"href\": this.wavURL,\n          \"download\": this.wavFilename\n        }, function(__root) {\n          __root.buffer(\"Download .wav\\n\");\n        }));\n        __root.buffer(__root.element(\"a\", this, {\n          \"href\": this.sfxzURL,\n          \"download\": this.sfxzFilename\n        }, function(__root) {\n          __root.buffer(\"Download .sfxz\\n\");\n        }));\n      }));\n      __root.buffer(this.canvas);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "models/effect": {
      "path": "models/effect",
      "content": "(function() {\n  var Mutator, Observable, Params, SFXZ, Serializer, Wav, _ref,\n    __slice = [].slice;\n\n  Observable = require(\"/lib/jadelet-runtime\").Observable;\n\n  Wav = require(\"../lib/wav\");\n\n  _ref = SFXZ = require(\"sfxz\"), Params = _ref.Params, Serializer = _ref.Serializer;\n\n  Mutator = require(\"../mutator\");\n\n  module.exports = function() {\n    var audioBuffer, listeners, params, self, sfxzBlob, updateSfxzURL, updateWavURL;\n    params = new Params;\n    audioBuffer = null;\n    sfxzBlob = null;\n    updateSfxzURL = function() {\n      var oldURL, sfxzBuffer;\n      oldURL = self.sfxzURL();\n      if (oldURL) {\n        URL.revokeObjectURL(oldURL);\n      }\n      sfxzBuffer = Serializer.serialize(params);\n      sfxzBlob = new Blob([sfxzBuffer], {\n        type: \"application/sfxz\"\n      });\n      return self.sfxzURL(URL.createObjectURL(sfxzBlob));\n    };\n    updateWavURL = function() {\n      var oldURL, wavFile;\n      oldURL = self.wavURL();\n      if (oldURL) {\n        URL.revokeObjectURL(oldURL);\n      }\n      wavFile = Wav(self.samples());\n      return self.wavURL(URL.createObjectURL(wavFile));\n    };\n    listeners = {};\n    self = {\n      regenerate: function() {\n        audioBuffer = SFXZ(params, audioContext);\n        updateSfxzURL();\n        updateWavURL();\n        return self.trigger(\"update\");\n      },\n      randomOfType: function(type) {\n        params = Mutator[type](Mutator.reset(params));\n        return self.regenerate();\n      },\n      params: function() {\n        return params;\n      },\n      samples: function() {\n        return audioBuffer.getChannelData(0);\n      },\n      wavFilename: \"sound.wav\",\n      wavURL: Observable(null),\n      sfxzFilename: \"sound.sfxz\",\n      sfxzURL: Observable(null),\n      playing: Observable(false),\n      play: function() {\n        var node;\n        node = new AudioBufferSourceNode(audioContext, {\n          buffer: audioBuffer\n        });\n        node.connect(audioContext.destination);\n        node.addEventListener(\"ended\", function(e) {\n          console.log(\"Ended\", e);\n          return self.playing(false);\n        });\n        self.playing(true);\n        return node.start();\n      },\n      on: function(type, listener) {\n        if (listeners[type] == null) {\n          listeners[type] = [];\n        }\n        listeners[type].push(listener);\n        return self;\n      },\n      trigger: function() {\n        var args, type, _ref1;\n        type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        return (_ref1 = listeners[type]) != null ? _ref1.forEach(function(listener) {\n          return listener.apply.apply(listener, [self].concat(__slice.call(args)));\n        }) : void 0;\n      }\n    };\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/wav": {
      "path": "lib/wav",
      "content": "(function() {\n  var RIFFWAVE, createWavData;\n\n  RIFFWAVE = require(\"./riffwav\");\n\n  createWavData = function(samples, eightBit) {\n    var bitsPerSample, buffer, clipCount;\n    if (eightBit == null) {\n      eightBit = false;\n    }\n    if (eightBit) {\n      bitsPerSample = 8;\n      buffer = new Uint8Array(samples.length);\n    } else {\n      bitsPerSample = 16;\n      buffer = new Uint8Array(samples.length * 2);\n    }\n    clipCount = 0;\n    samples.forEach(function(sample, i) {\n      if (eightBit) {\n        sample = Math.floor((sample + 1) * 128);\n        if (sample > 255) {\n          sample = 255;\n          ++clipCount;\n        } else if (sample < 0) {\n          sample = 0;\n          ++clipCount;\n        }\n        return buffer[i] = sample;\n      } else {\n        sample = Math.floor(sample * (1 << 15));\n        if (sample >= (1 << 15)) {\n          sample = (1 << 15) - 1;\n          ++clipCount;\n        } else if (sample < -(1 << 15)) {\n          sample = -(1 << 15);\n          ++clipCount;\n        }\n        buffer[2 * i] = sample & 0xFF;\n        return buffer[2 * i + 1] = (sample >> 8) & 0xFF;\n      }\n    });\n    return {\n      buffer: buffer,\n      clipCount: clipCount,\n      bitsPerSample: bitsPerSample\n    };\n  };\n\n  module.exports = function(samples, sampleRate) {\n    var bitsPerSample, buffer, clipCount, wave, _ref;\n    if (sampleRate == null) {\n      sampleRate = 44100;\n    }\n    _ref = createWavData(samples), buffer = _ref.buffer, clipCount = _ref.clipCount, bitsPerSample = _ref.bitsPerSample;\n    wave = new RIFFWAVE();\n    wave.header.sampleRate = sampleRate;\n    wave.header.bitsPerSample = bitsPerSample;\n    return wave.Make(buffer);\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "presenters/effect": {
      "path": "presenters/effect",
      "content": "(function() {\n  var EffectTemplate, Spectrum;\n\n  EffectTemplate = require(\"../templates/effect\");\n\n  Spectrum = require(\"../spectrum\");\n\n  module.exports = function(effect) {\n    var element, timeDomainCanvas;\n    effect.on(\"update\", function() {\n      return Spectrum(effect.samples(), timeDomainCanvas, element.clientWidth);\n    });\n    timeDomainCanvas = document.createElement('canvas');\n    effect.canvas = timeDomainCanvas;\n    element = EffectTemplate(effect);\n    return element;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/jadelet-runtime": {
      "path": "lib/jadelet-runtime",
      "content": "!function(n){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=n();else if(\"function\"==typeof define&&define.amd)define([],n);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JadeletRuntime=n()}}(function(){return function n(e,t,r){function o(i,c){if(!t[i]){if(!e[i]){var f=\"function\"==typeof require&&require;if(!c&&f)return f(i,!0);if(u)return u(i,!0);var l=new Error(\"Cannot find module '\"+i+\"'\");throw l.code=\"MODULE_NOT_FOUND\",l}var a=t[i]={exports:{}};e[i][0].call(a.exports,function(n){var t=e[i][1][n];return o(t||n)},a,a.exports,n,e,t,r)}return t[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<r.length;i++)o(r[i]);return o}({1:[function(n,e,t){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a,s,d,p,v,h,g,y,b,m,E,O,_,x,w,A,C;t=n(\"o_0\"),a=new WeakMap,s=new WeakMap,_=function(n){var e;e=s.get(n)||0,s.set(n,e+1)},O=function(n){var e;e=s.get(n)||0,--e>0?s.set(n,e):(s.delete(n),l(n))},l=function(n){var e,t;null!=(e=n.children)&&Array.prototype.forEach.call(e,l),null!=(t=a.get(n))&&t.forEach(function(e){e(),a.delete(n)})},o=function(n,e){var t;(t=a.get(n))?t.push(e):a.set(n,[e])},p=/^on(touch|animation|transition)(start|iteration|move|end|cancel)$/,h=function(n,e){return n.match(p)||n in e},A=function(n,e,t){switch(n.nodeName){case\"SELECT\":n.oninput=n.onchange=function(){var n,t,r;n=(t=this.children[this.selectedIndex]).value,r=t._value,\"function\"==typeof e&&e(r||n)},i(n,e,t,function(e){var t;n._value=e,(t=n._options)?null!=e.value?n.value=(\"function\"==typeof e.value?e.value():void 0)||e.value:n.selectedIndex=C(t,e):n.value=e});break;default:n.oninput=n.onchange=function(){\"function\"==typeof e&&e(n.value)},i(n,e,t,function(e){n.value!==e&&(n.value=e)})}},x={INPUT:{checked:function(n,e,t){return n.onchange=function(){\"function\"==typeof e&&e(n.checked)},i(n,e,t,function(e){n.checked=e})}},SELECT:{options:function(n,e,t){i(n,e,t,function(e){d(n),n._options=e,e.map(function(e,t){var r,o,u;return r=f(\"option\"),r._value=e,u=g(e)?(null!=e?e.value:void 0)||t:e.toString(),i(r,u,e,function(n){r.value=n}),o=(null!=e?e.name:void 0)||e,i(r,o,e,function(n){r.textContent=n}),n.appendChild(r),e===n._value&&(n.selectedIndex=t),r})})}}},b=function(n,e,t,r){var o,c,f;c=n.nodeName,\"value\"===t?A(n,r):(o=null!=(f=x[c])?f[t]:void 0)?o(n,r,e):t.match(/^on/)&&h(t,n)?u(n,t.substr(2),r,e):h(\"on\"+t,n)?u(n,t,r,e):i(n,r,e,function(e){null!=e&&!1!==e?n.setAttribute(t,e):n.removeAttribute(t)})},m=function(n,e,t){c(n,e,t,\"id\",function(e){var t;t=e[e.length-1],e.length?n.id=t:n.removeAttribute(\"id\")}),c(n,e,t,\"class\",function(e){n.className=e.join(\" \")}),c(n,e,t,\"style\",function(e){n.removeAttribute(\"style\"),e.forEach(function(e){return g(e)?Object.assign(n.style,e):n.setAttribute(\"style\",e)})}),Object.keys(t).forEach(function(r){b(n,e,r,t[r])})},i=function(n,e,r,u){var i;i=t(function(){u(v(e,r))}),o(n,i.releaseDependencies)},u=function(n,e,t,r){\"function\"==typeof t&&n.addEventListener(e,t.bind(r))},c=function(n,e,t,r,o){var u;null!=(u=t[r])&&(delete t[r],i(n,function(){return w(u,e)},e,o))},E=function(n,e,t){var r;r=function(e){null==e||(\"function\"==typeof e.forEach?e.forEach(r):e instanceof Node?(_(e),n.appendChild(e)):n.appendChild(document.createTextNode(e)))},i(n,function(){var n;return n=[],t.call(e,{buffer:function(t){n.push(v(t,e))},element:y}),n},e,function(e){d(n),e.forEach(r)})},y=function(n,e,t,r){var o;return o=f(n),m(o,e,t),\"SELECT\"!==o.nodeName&&E(o,e,r),o},(r=function(n){var e;return e={buffer:function(n){if(e.root)throw new Error(\"Cannot have multiple root elements\");e.root=n},element:y}}).Observable=t,r._elementCleaners=a,r._dispose=l,r.retain=_,r.release=O,e.exports=r,f=function(n){return document.createElement(n)},d=function(n){for(var e;e=n.firstChild;)n.removeChild(e),O(e)},g=function(n){return\"object\"==typeof n},C=function(n,e){return g(e)?n.indexOf(e):n.map(function(n){return n.toString()}).indexOf(e.toString())},w=function(n,e){return n.map(function(n){return v(n,e)}).reduce(function(n,e){return n.concat(v(e))},[]).filter(function(n){return null!=n})},v=function(n,e){return\"function\"==typeof n?n.call(e):n}}).call(this)},{o_0:2}],2:[function(n,e,t){(function(n){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a=[].slice;e.exports=function(n,e){var u,s,d,p,v;return\"function\"==typeof(null!=n?n.observe:void 0)?n:(d=[],p=function(n){return r(d).forEach(function(e){return e(n)})},\"function\"==typeof n?(s=n,(v=function(){return i(v),n}).releaseDependencies=function(){var n;return null!=(n=v._observableDependencies)?n.forEach(function(n){return n.stopObserving(u)}):void 0},(u=function(){var t;return t=new Set,n=l(t,s,e),v.releaseDependencies(),v._observableDependencies=t,t.forEach(function(n){return n.observe(u)}),p(n)})()):(v=function(e){return arguments.length>0?n!==e&&(n=e,p(e)):i(v),n}).releaseDependencies=c,Array.isArray(n)&&([\"concat\",\"every\",\"filter\",\"forEach\",\"indexOf\",\"join\",\"lastIndexOf\",\"map\",\"reduce\",\"reduceRight\",\"slice\",\"some\"].forEach(function(e){return v[e]=function(){var t;return t=1<=arguments.length?a.call(arguments,0):[],i(v),n[e].apply(n,t)}}),[\"pop\",\"push\",\"reverse\",\"shift\",\"splice\",\"sort\",\"unshift\"].forEach(function(e){return v[e]=function(){var t,r;return t=1<=arguments.length?a.call(arguments,0):[],r=n[e].apply(n,t),p(n),r}}),t&&Object.defineProperty(v,\"length\",{get:function(){return i(v),n.length},set:function(e){var t;return t=n.length=e,p(n),t}}),o(v,{remove:function(e){var t,r;if((t=n.indexOf(e))>=0)return r=n.splice(t,1)[0],p(n),r},get:function(e){return i(v),n[e]},first:function(){return i(v),n[0]},last:function(){return i(v),n[n.length-1]},size:function(){return i(v),n.length}})),o(v,{listeners:d,observe:function(n){return d.push(n)},stopObserving:function(n){return f(d,n)},toggle:function(){return v(!n)},increment:function(e){return null==e&&(e=1),v(n+e)},decrement:function(e){return null==e&&(e=1),v(n-e)},toString:function(){return\"Observable(\"+n+\")\"}}),v)},o=Object.assign,n.OBSERVABLE_ROOT_HACK=[],i=function(e){var t;if(t=u(n.OBSERVABLE_ROOT_HACK))return t.add(e)},l=function(e,t,r){n.OBSERVABLE_ROOT_HACK.push(e);try{return t.call(r)}finally{n.OBSERVABLE_ROOT_HACK.pop()}},f=function(n,e){var t;if((t=n.indexOf(e))>=0)return n.splice(t,1)[0]},r=function(n){return n.concat([])},u=function(n){return n[n.length-1]},c=function(){};try{Object.defineProperty(function(){},\"length\",{get:c,set:c}),t=!0}catch(n){t=!1}}).call(this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)});\n",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "https://danielx.net/editor/"
  },
  "config": {
    "name": "SFXZ Edit",
    "version": "0.1.0",
    "dependencies": {
      "sfxz": "STRd6/sfxz:v0.3.1"
    }
  },
  "version": "0.1.0",
  "entryPoint": "main",
  "repository": {
    "branch": "master",
    "default_branch": "master",
    "full_name": "STRd6/sfxz-edit",
    "homepage": null,
    "description": "An editor for sfxz, like jsfxr",
    "html_url": "https://github.com/STRd6/sfxz-edit",
    "url": "https://api.github.com/repos/STRd6/sfxz-edit",
    "publishBranch": "gh-pages"
  },
  "dependencies": {
    "sfxz": {
      "source": {
        "README.md": {
          "path": "README.md",
          "content": "SFXZ\n====\n\nA recreation of sfxr. Wish me luck!\n\n\nGoals\n-----\n\n- [ ] An embeddable synthesizer in < 1kb js (minified and gzipped)\n- [x] A binary format for saving and loading effects in 100 bytes\n\nSFXZ Binary Format Specification\n------\n\n| Offset | Size | Type    | Field            | Range  |\n|--------|------|---------|------------------|--------|\n|  0     | 3    | ascii   | Magic Number     | 'fxz'  |\n|  3     | 1    | uint8   | version          | 1      |\n|  4     | 1    | uint8   | wave shape       | 0-3    |\n|  5     | 3    | -       | unused           | 0      |\n|  8     | 4    | float32 | attack time      | [ 0,1] |\n| 12     | 4    | float32 | sustain time     | [ 0,1] |\n| 16     | 4    | float32 | sustain punch    | [ 0,1] |\n| 20     | 4    | float32 | decay time       | [ 0,1] |\n| 24     | 4    | float32 | start frequency  | [ 0,1] |\n| 28     | 4    | float32 | frequency cutoff | [ 0,1] |\n| 32     | 4    | float32 | frequency slide  | [-1,1] |\n| 36     | 4    | float32 | delta slide      | [-1,1] |\n| 40     | 4    | float32 | vibrato depth    | [ 0,1] |\n| 44     | 4    | float32 | vibrato speed    | [ 0,1] |\n| 48     | 4    | float32 | arp amount       | [-1,1] |\n| 52     | 4    | float32 | arp change speed | [ 0,1] |\n| 56     | 4    | float32 | Square duty      | [ 0,1] |\n| 60     | 4    | float32 | Duty sweep       | [-1,1] |\n| 64     | 4    | float32 | Repeat speed     | [ 0,1] |\n| 68     | 4    | float32 | Flanger offset   | [-1,1] |\n| 72     | 4    | float32 | Flanger sweep    | [-1,1] |\n| 76     | 4    | float32 | LPF cutoff       | [ 0,1] |\n| 80     | 4    | float32 | LPF cutoff sweep | [-1,1] |\n| 84     | 4    | float32 | LPF resonance    | [ 0,1] |\n| 88     | 4    | float32 | HPF cutoff       | [ 0,1] |\n| 92     | 4    | float32 | HPF cutoff sweep | [-1,1] |\n| 96     | 4    | float32 | Volume           | [ 0,1] |\n\nRecommended MIME type `application/sfxz`.\n\nRecommended file extension `.sfxz`.\n\nStatus\n------\n\nCurrently in beta. I want to review the synth and see if I can adjust the params\nto reduce the amount that create empty or \"bad\" sounds. Juice the most \ninformation out of those bits!\n\nI also want to investigate using the full float32 range or expanding the \nrecommended range and see what impact that will have, but I need to learn more \nabout how the synth operates to be sure.\n\nGlossary\n------\n\n- freq: frequency\n- LPF: Low pass filter\n- vol: Volume\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "name: \"SFXZ\"\nversion: \"0.3.1\"\nentryPoint: \"sfxz\"\npublish:\n  s3:\n    basePath: \"public/danielx.net\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "serializer.coffee": {
          "path": "serializer.coffee",
          "content": "VERSION = 1\n\nmodule.exports =\n  serialize: (params) ->\n    buffer = new ArrayBuffer(100)\n\n    dataView = new DataView(buffer)\n\n    Object.keys(params).forEach (key, i) ->\n      param = params[key]\n      if i is 0\n        # 4 byte sfxz header\n        \"fxz\".split(\"\").forEach (s, n) ->\n          dataView.setUint8(n, s.charCodeAt(0))\n        # version\n        dataView.setUint8(3, VERSION)\n        # byte 4 shape\n        dataView.setUint8(4, param)\n        # bytes 5, 6, 7 unused for now\n      else\n        # Little endian float32s for the other 23 fields\n        dataView.setFloat32((i + 1) * 4, param, true)\n\n    return buffer\n\n  deserialize: (buffer, params) ->\n    dataView = new DataView(buffer)\n\n    Object.keys(params).forEach (key, i) ->\n      if i is 0\n        # 4 byte sfxz header\n        \"fxz\".split(\"\").forEach (s, n) ->\n          charCode = s.charCodeAt(0)\n          if charCode != dataView.getUint8(n)\n            throw new Error \"Unknown file format: expected '#{s}' (#{charCode}) at byte #{n}\"\n        # version\n        version = dataView.getUint8(3)\n        if version != VERSION\n          throw new Error \"Unknown version '#{version}': expected 1\"\n        # byte 4 shape\n        params[key] = dataView.getUint8(4)\n        # bytes 5, 6, 7 unused for now\n      else\n        # Little endian float32s for the other 23 fields\n        params[key] = dataView.getFloat32((i + 1) * 4, true)\n\n    return params\n",
          "mode": "100644",
          "type": "blob"
        },
        "sfxz.js": {
          "path": "sfxz.js",
          "content": "// Synthesize an AudioBuffer from the param data\nmodule.exports = (function() {\n  // Sound generation parameters are on [0,1] unless noted SIGNED & thus on [-1,1]\n  function Params() {\n    // Wave shape\n    this.shape = 0;\n\n    // Envelope\n    this.attack = 0;    // Attack time\n    this.sustain = 0.3; // Sustain time\n    this.punch = 0;     // Sustain punch\n    this.decay = 0.4;   // Decay time\n\n    // Tone\n    this.freq = 0.3;    // Start frequency\n    this.freqLimit = 0;   // Min frequency cutoff\n    this.freqSlide = 0;    // Slide (SIGNED)\n    this.freqSlideDelta = 0;   // Delta slide (SIGNED)\n    // Vibrato\n    this.vibDepth = 0; // Vibrato depth\n    this.vibSpeed = 0;    // Vibrato speed\n\n    // Tonal change\n    this.arpMod = 0;      // Change amount (SIGNED)\n    this.arpSpeed = 0;    // Change speed\n\n    // Square wave duty (proportion of time signal is high vs. low)\n    this.duty = 0;         // Square duty\n    this.dutySweep = 0;    // Duty sweep (SIGNED)\n\n    // Repeat\n    this.repeatSpeed = 0; // Repeat speed\n\n    // Flanger\n    this.flangerOffset = 0;   // Flanger offset (SIGNED)\n    this.flangerSweep = 0;     // Flanger sweep (SIGNED)\n\n    // Low-pass filter\n    this.lpf = 1;     // Low-pass filter cutoff\n    this.lpfSweep = 0;     // Low-pass filter cutoff sweep (SIGNED)\n    this.lpfResonance = 0;// Low-pass filter resonance\n    // High-pass filter\n    this.hpf = 0;     // High-pass filter cutoff\n    this.hpfSweep = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n    // Sample parameters\n    this.vol = 0.5;\n  }\n\n  function SFXZ(ps, audioContext) {\n    // Handle binary format\n    if (ps instanceof ArrayBuffer) {\n      ps = Serializer.deserialize(ps, new Params());\n    }\n\n    var m = Math;\n    var floor = m.floor,\n      pow = m.pow,\n      abs = m.abs,\n      random = m.random;\n\n    var SQUARE = 0,\n      SAWTOOTH = 1,\n      SINE = 2,\n      NOISE = 3,\n      OVERSAMPLING = 8,\n      sampleRate = 44100;\n\n    var i,\n      elapsedSinceRepeat,\n      period,\n      periodMax,\n      enableFrequencyCutoff,\n      periodMult,\n      periodMultSlide,\n      dutyCycle,\n      dutyCycleSlide,\n      arpeggioMultiplier,\n      arpeggioTime;\n\n    function initForRepeat() {\n      elapsedSinceRepeat = 0;\n\n      period = 100 / (ps.freq * ps.freq + 0.001);\n      periodMax = 100 / (ps.freqLimit * ps.freqLimit + 0.001);\n      enableFrequencyCutoff = (ps.freqLimit > 0);\n      periodMult = 1 - pow(ps.freqSlide, 3) * 0.01;\n      periodMultSlide = -pow(ps.freqSlideDelta, 3) * 0.000001;\n\n      dutyCycle = 0.5 - ps.duty * 0.5;\n      dutyCycleSlide = -ps.dutySweep * 0.00005;\n\n      if (ps.arpMod >= 0)\n        arpeggioMultiplier = 1 - pow(ps.arpMod, 2) * 0.9;\n      else\n        arpeggioMultiplier = 1 + pow(ps.arpMod, 2) * 10;\n      arpeggioTime = floor(pow(1 - ps.arpSpeed, 2) * 20000 + 32);\n      if (ps.arpSpeed === 1)\n        arpeggioTime = 0;\n    }\n\n    initForRepeat();\n\n    // Waveform shape\n    var waveShape = parseInt(ps.shape);\n\n    // Filter\n    var fltw = pow(ps.lpf, 3) * 0.1;\n    var enableLowPassFilter = (ps.lpf != 1);\n    var fltw_d = 1 + ps.lpfSweep * 0.0001;\n    var fltdmp = 5 / (1 + pow(ps.lpfResonance, 2) * 20) * (0.01 + fltw);\n    if (fltdmp > 0.8)\n      fltdmp=0.8;\n    var flthp = pow(ps.hpf, 2) * 0.1;\n    var flthp_d = 1 + ps.hpfSweep * 0.0003;\n\n    // Vibrato\n    var vibratoSpeed = pow(ps.vibSpeed, 2) * 0.01;\n    var vibratoAmplitude = ps.vibDepth * 0.5;\n\n    // Envelope\n    var envelopeLength = [\n      floor(ps.attack * ps.attack * 100000),\n      floor(ps.sustain * ps.sustain * 100000),\n      floor(ps.decay * ps.decay * 100000)\n    ];\n    var envelopePunch = ps.punch;\n\n    // Flanger\n    var flangerOffset = pow(ps.flangerOffset, 2) * 1020;\n    if (ps.flangerOffset < 0)\n      flangerOffset = -flangerOffset;\n    var flangerOffsetSlide = pow(ps.flangerSweep, 2) * 1;\n    if (ps.flangerSweep < 0)\n      flangerOffsetSlide = -flangerOffsetSlide;\n\n    // Repeat\n    var repeatTime = floor(pow(1 - ps.repeatSpeed, 2) * 20000 + 32);\n    if (ps.repeatSpeed === 0)\n      repeatTime = 0;\n\n    var gain = pow(2, ps.vol) - 1;\n\n    var fltp = 0;\n    var fltdp = 0;\n    var fltphp = 0;\n\n    // TODO: Deterministic output! Don't randomize noise buffer here\n    var noise_buffer = [];\n    for (i = 0; i < 32; ++i)\n      noise_buffer[i] = random() * 2 - 1;\n\n    var envelopeStage = 0;\n    var envelopeElapsed = 0;\n\n    var vibratoPhase = 0;\n\n    var phase = 0;\n    var ipp = 0;\n    var flanger_buffer = [];\n    for (i = 0; i < 1024; ++i)\n      flanger_buffer[i] = 0;\n\n    var num_clipped = 0;\n\n    var buffer = [];\n\n    for(var t = 0; ; ++t) {\n\n      // Repeats\n      if (repeatTime !== 0 && ++elapsedSinceRepeat >= repeatTime)\n        initForRepeat();\n\n      // Arpeggio (single)\n      if(arpeggioTime !== 0 && t >= arpeggioTime) {\n        arpeggioTime = 0;\n        period *= arpeggioMultiplier;\n      }\n\n      // Frequency slide, and frequency slide slide!\n      periodMult += periodMultSlide;\n      period *= periodMult;\n      if(period > periodMax) {\n        period = periodMax;\n        if (enableFrequencyCutoff)\n          break;\n      }\n\n      // Vibrato\n      var rfperiod = period;\n      if (vibratoAmplitude > 0) {\n        vibratoPhase += vibratoSpeed;\n        rfperiod = period * (1 + m.sin(vibratoPhase) * vibratoAmplitude);\n      }\n      var iperiod = floor(rfperiod);\n      if (iperiod < OVERSAMPLING)\n        iperiod = OVERSAMPLING;\n\n      // Square wave duty cycle\n      dutyCycle += dutyCycleSlide;\n      if (dutyCycle < 0)\n        dutyCycle = 0;\n      if (dutyCycle > 0.5)\n        dutyCycle = 0.5;\n\n      // Volume envelope\n      if (++envelopeElapsed > envelopeLength[envelopeStage]) {\n        envelopeElapsed = 0;\n        if (++envelopeStage > 2)\n          break;\n      }\n      var env_vol;\n      var envf = envelopeElapsed / envelopeLength[envelopeStage];\n      if (envelopeStage === 0) {         // Attack\n        env_vol = envf;\n      } else if (envelopeStage === 1) {  // Sustain\n        env_vol = 1 + (1 - envf) * 2 * envelopePunch;\n      } else {                           // Decay\n        env_vol = 1 - envf;\n      }\n\n      // Flanger step\n      flangerOffset += flangerOffsetSlide;\n      var iphase = abs(floor(flangerOffset));\n      if (iphase > 1023)\n        iphase = 1023;\n\n      if (flthp_d !== 0) {\n        flthp *= flthp_d;\n        if (flthp < 0.00001)\n          flthp = 0.00001;\n        if (flthp > 0.1)\n          flthp = 0.1;\n      }\n\n      // 8x oversampling\n      var sample = 0;\n      for (var si = 0; si < OVERSAMPLING; ++si) {\n        var sub_sample = 0;\n        phase++;\n        if (phase >= iperiod) {\n          phase %= iperiod;\n          if (waveShape === NOISE)\n            for(var i = 0; i < 32; ++i)\n              noise_buffer[i] = random() * 2 - 1;\n        }\n\n        // Base waveform\n        var fp = phase / iperiod;\n        if (waveShape === SQUARE) {\n          if (fp < dutyCycle)\n            sub_sample=0.5;\n          else\n            sub_sample=-0.5;\n        } else if (waveShape === SAWTOOTH) {\n          if (fp < dutyCycle)\n            sub_sample = -1 + 2 * fp/dutyCycle;\n          else\n            sub_sample = 1 - 2 * (fp-dutyCycle)/(1-dutyCycle);\n        } else if (waveShape === SINE) {\n          sub_sample = m.sin(fp * 2 * m.PI);\n        } else if (waveShape === NOISE) {\n          sub_sample = noise_buffer[floor(phase * 32 / iperiod)];\n        } else {\n          throw \"ERROR: Bad wave type: \" + waveShape;\n        }\n\n        // Low-pass filter\n        var pp = fltp;\n        fltw *= fltw_d;\n        if (fltw < 0)\n          fltw = 0;\n        if (fltw > 0.1)\n          fltw = 0.1;\n        if (enableLowPassFilter) {\n          fltdp += (sub_sample - fltp) * fltw;\n          fltdp -= fltdp * fltdmp;\n        } else {\n          fltp = sub_sample;\n          fltdp = 0;\n        }\n        fltp += fltdp;\n\n        // High-pass filter\n        fltphp += fltp - pp;\n        fltphp -= fltphp * flthp;\n        sub_sample = fltphp;\n\n        // Flanger\n        flanger_buffer[ipp & 1023] = sub_sample;\n        sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n        ipp = (ipp + 1) & 1023;\n\n        // final accumulation and envelope application\n        sample += sub_sample * env_vol;\n      }\n\n      sample = sample / OVERSAMPLING;\n      sample *= gain;\n\n      buffer.push(sample);\n    }\n\n    // Create buffer\n    var audioBuffer = audioContext.createBuffer(1, buffer.length || 1, sampleRate);\n    audioBuffer.getChannelData(0).set(new Float32Array(buffer));\n\n    return audioBuffer;\n  };\n\n  var Serializer = SFXZ.Serializer = require(\"./serializer\");\n  SFXZ.Params = Params;\n\n  return SFXZ;\n})();\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/params.coffee": {
          "path": "test/params.coffee",
          "content": "global.SFXZ = require \"../sfxz\"\n\nconsole.log SFXZ\n\nequalEnough = (a, b, precision=5) ->\n  console.log \"equalEnough\", a, b\n  assert.equal a.toFixed(precision), b.toFixed(precision)\n\nrand = Math.random\n\ndescribe \"SFXZ\", ->\n  it \"should expose Params\", ->\n    assert SFXZ.Params\n\n  it \"should expose Serializer\", ->\n    assert SFXZ.Serializer\n\n  describe \"Serialization\", ->\n    it \"should serialize and deserialize\", ->\n      {Params, Serializer} = SFXZ\n      {serialize, deserialize} = Serializer\n\n      p1 = new Params\n      # Randomize values\n      Object.keys(p1).forEach (key, i) ->\n        if i > 0\n          p1[key] = rand()\n\n      buffer = serialize p1\n\n      assert.equal buffer.byteLength, 100\n\n      p2 = deserialize(buffer, new Params)\n\n      Object.keys(p1).forEach (key, i) ->\n        if i > 0\n          equalEnough p1[key], p2[key]\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"name\":\"SFXZ\",\"version\":\"0.3.1\",\"entryPoint\":\"sfxz\",\"publish\":{\"s3\":{\"basePath\":\"public/danielx.net\"}}};",
          "type": "blob"
        },
        "serializer": {
          "path": "serializer",
          "content": "(function() {\n  var VERSION;\n\n  VERSION = 1;\n\n  module.exports = {\n    serialize: function(params) {\n      var buffer, dataView;\n      buffer = new ArrayBuffer(100);\n      dataView = new DataView(buffer);\n      Object.keys(params).forEach(function(key, i) {\n        var param;\n        param = params[key];\n        if (i === 0) {\n          \"fxz\".split(\"\").forEach(function(s, n) {\n            return dataView.setUint8(n, s.charCodeAt(0));\n          });\n          dataView.setUint8(3, VERSION);\n          return dataView.setUint8(4, param);\n        } else {\n          return dataView.setFloat32((i + 1) * 4, param, true);\n        }\n      });\n      return buffer;\n    },\n    deserialize: function(buffer, params) {\n      var dataView;\n      dataView = new DataView(buffer);\n      Object.keys(params).forEach(function(key, i) {\n        var version;\n        if (i === 0) {\n          \"fxz\".split(\"\").forEach(function(s, n) {\n            var charCode;\n            charCode = s.charCodeAt(0);\n            if (charCode !== dataView.getUint8(n)) {\n              throw new Error(\"Unknown file format: expected '\" + s + \"' (\" + charCode + \") at byte \" + n);\n            }\n          });\n          version = dataView.getUint8(3);\n          if (version !== VERSION) {\n            throw new Error(\"Unknown version '\" + version + \"': expected 1\");\n          }\n          return params[key] = dataView.getUint8(4);\n        } else {\n          return params[key] = dataView.getFloat32((i + 1) * 4, true);\n        }\n      });\n      return params;\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "sfxz": {
          "path": "sfxz",
          "content": "// Synthesize an AudioBuffer from the param data\nmodule.exports = (function() {\n  // Sound generation parameters are on [0,1] unless noted SIGNED & thus on [-1,1]\n  function Params() {\n    // Wave shape\n    this.shape = 0;\n\n    // Envelope\n    this.attack = 0;    // Attack time\n    this.sustain = 0.3; // Sustain time\n    this.punch = 0;     // Sustain punch\n    this.decay = 0.4;   // Decay time\n\n    // Tone\n    this.freq = 0.3;    // Start frequency\n    this.freqLimit = 0;   // Min frequency cutoff\n    this.freqSlide = 0;    // Slide (SIGNED)\n    this.freqSlideDelta = 0;   // Delta slide (SIGNED)\n    // Vibrato\n    this.vibDepth = 0; // Vibrato depth\n    this.vibSpeed = 0;    // Vibrato speed\n\n    // Tonal change\n    this.arpMod = 0;      // Change amount (SIGNED)\n    this.arpSpeed = 0;    // Change speed\n\n    // Square wave duty (proportion of time signal is high vs. low)\n    this.duty = 0;         // Square duty\n    this.dutySweep = 0;    // Duty sweep (SIGNED)\n\n    // Repeat\n    this.repeatSpeed = 0; // Repeat speed\n\n    // Flanger\n    this.flangerOffset = 0;   // Flanger offset (SIGNED)\n    this.flangerSweep = 0;     // Flanger sweep (SIGNED)\n\n    // Low-pass filter\n    this.lpf = 1;     // Low-pass filter cutoff\n    this.lpfSweep = 0;     // Low-pass filter cutoff sweep (SIGNED)\n    this.lpfResonance = 0;// Low-pass filter resonance\n    // High-pass filter\n    this.hpf = 0;     // High-pass filter cutoff\n    this.hpfSweep = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n    // Sample parameters\n    this.vol = 0.5;\n  }\n\n  function SFXZ(ps, audioContext) {\n    // Handle binary format\n    if (ps instanceof ArrayBuffer) {\n      ps = Serializer.deserialize(ps, new Params());\n    }\n\n    var m = Math;\n    var floor = m.floor,\n      pow = m.pow,\n      abs = m.abs,\n      random = m.random;\n\n    var SQUARE = 0,\n      SAWTOOTH = 1,\n      SINE = 2,\n      NOISE = 3,\n      OVERSAMPLING = 8,\n      sampleRate = 44100;\n\n    var i,\n      elapsedSinceRepeat,\n      period,\n      periodMax,\n      enableFrequencyCutoff,\n      periodMult,\n      periodMultSlide,\n      dutyCycle,\n      dutyCycleSlide,\n      arpeggioMultiplier,\n      arpeggioTime;\n\n    function initForRepeat() {\n      elapsedSinceRepeat = 0;\n\n      period = 100 / (ps.freq * ps.freq + 0.001);\n      periodMax = 100 / (ps.freqLimit * ps.freqLimit + 0.001);\n      enableFrequencyCutoff = (ps.freqLimit > 0);\n      periodMult = 1 - pow(ps.freqSlide, 3) * 0.01;\n      periodMultSlide = -pow(ps.freqSlideDelta, 3) * 0.000001;\n\n      dutyCycle = 0.5 - ps.duty * 0.5;\n      dutyCycleSlide = -ps.dutySweep * 0.00005;\n\n      if (ps.arpMod >= 0)\n        arpeggioMultiplier = 1 - pow(ps.arpMod, 2) * 0.9;\n      else\n        arpeggioMultiplier = 1 + pow(ps.arpMod, 2) * 10;\n      arpeggioTime = floor(pow(1 - ps.arpSpeed, 2) * 20000 + 32);\n      if (ps.arpSpeed === 1)\n        arpeggioTime = 0;\n    }\n\n    initForRepeat();\n\n    // Waveform shape\n    var waveShape = parseInt(ps.shape);\n\n    // Filter\n    var fltw = pow(ps.lpf, 3) * 0.1;\n    var enableLowPassFilter = (ps.lpf != 1);\n    var fltw_d = 1 + ps.lpfSweep * 0.0001;\n    var fltdmp = 5 / (1 + pow(ps.lpfResonance, 2) * 20) * (0.01 + fltw);\n    if (fltdmp > 0.8)\n      fltdmp=0.8;\n    var flthp = pow(ps.hpf, 2) * 0.1;\n    var flthp_d = 1 + ps.hpfSweep * 0.0003;\n\n    // Vibrato\n    var vibratoSpeed = pow(ps.vibSpeed, 2) * 0.01;\n    var vibratoAmplitude = ps.vibDepth * 0.5;\n\n    // Envelope\n    var envelopeLength = [\n      floor(ps.attack * ps.attack * 100000),\n      floor(ps.sustain * ps.sustain * 100000),\n      floor(ps.decay * ps.decay * 100000)\n    ];\n    var envelopePunch = ps.punch;\n\n    // Flanger\n    var flangerOffset = pow(ps.flangerOffset, 2) * 1020;\n    if (ps.flangerOffset < 0)\n      flangerOffset = -flangerOffset;\n    var flangerOffsetSlide = pow(ps.flangerSweep, 2) * 1;\n    if (ps.flangerSweep < 0)\n      flangerOffsetSlide = -flangerOffsetSlide;\n\n    // Repeat\n    var repeatTime = floor(pow(1 - ps.repeatSpeed, 2) * 20000 + 32);\n    if (ps.repeatSpeed === 0)\n      repeatTime = 0;\n\n    var gain = pow(2, ps.vol) - 1;\n\n    var fltp = 0;\n    var fltdp = 0;\n    var fltphp = 0;\n\n    // TODO: Deterministic output! Don't randomize noise buffer here\n    var noise_buffer = [];\n    for (i = 0; i < 32; ++i)\n      noise_buffer[i] = random() * 2 - 1;\n\n    var envelopeStage = 0;\n    var envelopeElapsed = 0;\n\n    var vibratoPhase = 0;\n\n    var phase = 0;\n    var ipp = 0;\n    var flanger_buffer = [];\n    for (i = 0; i < 1024; ++i)\n      flanger_buffer[i] = 0;\n\n    var num_clipped = 0;\n\n    var buffer = [];\n\n    for(var t = 0; ; ++t) {\n\n      // Repeats\n      if (repeatTime !== 0 && ++elapsedSinceRepeat >= repeatTime)\n        initForRepeat();\n\n      // Arpeggio (single)\n      if(arpeggioTime !== 0 && t >= arpeggioTime) {\n        arpeggioTime = 0;\n        period *= arpeggioMultiplier;\n      }\n\n      // Frequency slide, and frequency slide slide!\n      periodMult += periodMultSlide;\n      period *= periodMult;\n      if(period > periodMax) {\n        period = periodMax;\n        if (enableFrequencyCutoff)\n          break;\n      }\n\n      // Vibrato\n      var rfperiod = period;\n      if (vibratoAmplitude > 0) {\n        vibratoPhase += vibratoSpeed;\n        rfperiod = period * (1 + m.sin(vibratoPhase) * vibratoAmplitude);\n      }\n      var iperiod = floor(rfperiod);\n      if (iperiod < OVERSAMPLING)\n        iperiod = OVERSAMPLING;\n\n      // Square wave duty cycle\n      dutyCycle += dutyCycleSlide;\n      if (dutyCycle < 0)\n        dutyCycle = 0;\n      if (dutyCycle > 0.5)\n        dutyCycle = 0.5;\n\n      // Volume envelope\n      if (++envelopeElapsed > envelopeLength[envelopeStage]) {\n        envelopeElapsed = 0;\n        if (++envelopeStage > 2)\n          break;\n      }\n      var env_vol;\n      var envf = envelopeElapsed / envelopeLength[envelopeStage];\n      if (envelopeStage === 0) {         // Attack\n        env_vol = envf;\n      } else if (envelopeStage === 1) {  // Sustain\n        env_vol = 1 + (1 - envf) * 2 * envelopePunch;\n      } else {                           // Decay\n        env_vol = 1 - envf;\n      }\n\n      // Flanger step\n      flangerOffset += flangerOffsetSlide;\n      var iphase = abs(floor(flangerOffset));\n      if (iphase > 1023)\n        iphase = 1023;\n\n      if (flthp_d !== 0) {\n        flthp *= flthp_d;\n        if (flthp < 0.00001)\n          flthp = 0.00001;\n        if (flthp > 0.1)\n          flthp = 0.1;\n      }\n\n      // 8x oversampling\n      var sample = 0;\n      for (var si = 0; si < OVERSAMPLING; ++si) {\n        var sub_sample = 0;\n        phase++;\n        if (phase >= iperiod) {\n          phase %= iperiod;\n          if (waveShape === NOISE)\n            for(var i = 0; i < 32; ++i)\n              noise_buffer[i] = random() * 2 - 1;\n        }\n\n        // Base waveform\n        var fp = phase / iperiod;\n        if (waveShape === SQUARE) {\n          if (fp < dutyCycle)\n            sub_sample=0.5;\n          else\n            sub_sample=-0.5;\n        } else if (waveShape === SAWTOOTH) {\n          if (fp < dutyCycle)\n            sub_sample = -1 + 2 * fp/dutyCycle;\n          else\n            sub_sample = 1 - 2 * (fp-dutyCycle)/(1-dutyCycle);\n        } else if (waveShape === SINE) {\n          sub_sample = m.sin(fp * 2 * m.PI);\n        } else if (waveShape === NOISE) {\n          sub_sample = noise_buffer[floor(phase * 32 / iperiod)];\n        } else {\n          throw \"ERROR: Bad wave type: \" + waveShape;\n        }\n\n        // Low-pass filter\n        var pp = fltp;\n        fltw *= fltw_d;\n        if (fltw < 0)\n          fltw = 0;\n        if (fltw > 0.1)\n          fltw = 0.1;\n        if (enableLowPassFilter) {\n          fltdp += (sub_sample - fltp) * fltw;\n          fltdp -= fltdp * fltdmp;\n        } else {\n          fltp = sub_sample;\n          fltdp = 0;\n        }\n        fltp += fltdp;\n\n        // High-pass filter\n        fltphp += fltp - pp;\n        fltphp -= fltphp * flthp;\n        sub_sample = fltphp;\n\n        // Flanger\n        flanger_buffer[ipp & 1023] = sub_sample;\n        sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n        ipp = (ipp + 1) & 1023;\n\n        // final accumulation and envelope application\n        sample += sub_sample * env_vol;\n      }\n\n      sample = sample / OVERSAMPLING;\n      sample *= gain;\n\n      buffer.push(sample);\n    }\n\n    // Create buffer\n    var audioBuffer = audioContext.createBuffer(1, buffer.length || 1, sampleRate);\n    audioBuffer.getChannelData(0).set(new Float32Array(buffer));\n\n    return audioBuffer;\n  };\n\n  var Serializer = SFXZ.Serializer = require(\"./serializer\");\n  SFXZ.Params = Params;\n\n  return SFXZ;\n})();\n",
          "type": "blob"
        },
        "test/params": {
          "path": "test/params",
          "content": "(function() {\n  var equalEnough, rand;\n\n  global.SFXZ = require(\"../sfxz\");\n\n  console.log(SFXZ);\n\n  equalEnough = function(a, b, precision) {\n    if (precision == null) {\n      precision = 5;\n    }\n    console.log(\"equalEnough\", a, b);\n    return assert.equal(a.toFixed(precision), b.toFixed(precision));\n  };\n\n  rand = Math.random;\n\n  describe(\"SFXZ\", function() {\n    it(\"should expose Params\", function() {\n      return assert(SFXZ.Params);\n    });\n    it(\"should expose Serializer\", function() {\n      return assert(SFXZ.Serializer);\n    });\n    return describe(\"Serialization\", function() {\n      return it(\"should serialize and deserialize\", function() {\n        var Params, Serializer, buffer, deserialize, p1, p2, serialize;\n        Params = SFXZ.Params, Serializer = SFXZ.Serializer;\n        serialize = Serializer.serialize, deserialize = Serializer.deserialize;\n        p1 = new Params;\n        Object.keys(p1).forEach(function(key, i) {\n          if (i > 0) {\n            return p1[key] = rand();\n          }\n        });\n        buffer = serialize(p1);\n        assert.equal(buffer.byteLength, 100);\n        p2 = deserialize(buffer, new Params);\n        return Object.keys(p1).forEach(function(key, i) {\n          if (i > 0) {\n            return equalEnough(p1[key], p2[key]);\n          }\n        });\n      });\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "name": "SFXZ",
        "version": "0.3.1",
        "entryPoint": "sfxz",
        "publish": {
          "s3": {
            "basePath": "public/danielx.net"
          }
        }
      },
      "version": "0.3.1",
      "entryPoint": "sfxz",
      "repository": {
        "branch": "v0.3.1",
        "default_branch": "master",
        "full_name": "STRd6/sfxz",
        "homepage": "http://grumdrig.github.com/jsfxr/",
        "description": "Simple and efficient sound effects generator. A port of sfxr to HTML5.",
        "html_url": "https://github.com/STRd6/sfxz",
        "url": "https://api.github.com/repos/STRd6/sfxz",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    }
  }
});